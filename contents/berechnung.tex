%!TEX root = ../trajectory-grouping.tex
Zur Berechnung der \GrpStruktur müssen wir gemäß \cref{def:grpstrukur} den reduzierten Reeb-Graphen und die maximalen Gruppen berechnen.
Dazu berechnen wir zunächst die unreduzierten Reeb-Graphen $\mathcal{R}$ und dann die maximalen Gruppen. 
Mit diesen Informationen ist die Reduktion von $\mathcal{R}$ ein trivialer Nachbearbeitungsschritt.

Für die Berechnung des Reeb-Graphen ist eine Datenstruktur zur dynamischen Speicherung von Bäumen nötig.
Eine solche verwaltet einen Wald von Bäumen mit disjunkten Knotenmengen und unterstützt dabei eine Reihe von Operationen auf diesen Bäumen.
Die Operationen, die wir benötigen, sind in \cref{tbl:operationenST} aufgeführt.
\begin{table}[p]
	\Centering
	\caption{Operationen, die von ST-Bäumen unterstützt werden (nach \cite{parsaReeb})}\label{tbl:operationenST}
	\begin{tabular}{lp{.7\textwidth}}
		\toprule
		$\mathtt{parent}(x)$ & Gibt den Eltern-Knoten von $x$ zurück, falls dieser existiert; \texttt{null}, falls $x$ ein Wurzelknoten ist.\\
		$\mathtt{root}(x)$ & Gibt die Wurzel des Baumes zurück, zu dem $x$ gehört.\\
		$\mathtt{link}(x_1,x_2,w)$ & Verbindet verschiedene Bäume durch das Einfügen einer Kante zwischen $x_1$ und $x_2$, der das Gewicht $w$ zugeordnet wird.\\
		$\mathtt{cut}(x_1,x_2)$ & Entfernt die Kante zwischen $x_1$ und $x_2$ und trennt damit einen Baum in zwei auf.\\
		$\mathtt{minWeight}(x)$ & Gibt einen Knoten auf dem Pfad von $x$ zur Wurzel zurück, der minimales Gewicht zu seinem Elternknoten hat; \texttt{null}, falls $x$ ein Wurzelknoten ist.\\
		$\mathtt{evert}(x)$ & Macht $x$ zur Wurzel des Baumes, zu dem $x$ gehört.\\
		\bottomrule
	\end{tabular}
\end{table}
Eine Datenstruktur, die alle diese Operationen in $\mathcal{O}(\log n)$ Zeit, wobei $n$ die Gesamtzahl der Knoten ist, realisiert, ist unter anderem ein \Index{ST-Baum} nach \textcite{dynamictrees}.
Das im Folgenden geschilderte Vorgehen von \textcite{buchin2015} zur Berechnung des Reeb-Graphen $\mathcal{R}$ basiert auf einem Algorithmus von \textcite{parsaReeb}, der diese ST-Bäume benutzt.

\section{Berechnung des Reeb-Graphen} % (fold)
\label{sec:berechnung_reeb}
\todo[inline]{Bild zum Reeb-Graphen erneut einfügen oder referenzieren}
Wir wollen den Reeb-Graphen $\mathcal{R}$ des dreidimensionalen Raumes $\mathcal{M}$ aus \cref{sec:trajek_reeb} bezüglich der Höhenfunktion berechnen -- die \enquote{Höhe} ist hier aber die Zeit! 
Folglich ist es natürlich die Berechnung mittels eines Sweep-Algorithmus zu realisieren.
Unsere Sweep-Ebene ist also die $xy$-Ebene, die $\mathcal{M}$ von unten nach oben überstreicht.

In \cref{sec:background_reeb} über die differentialtopologischen Hintergründe haben wir bereits gesehen, dass sich der Reeb-Graph nur an den kritischen Werten verändert.\footnote{unter der Annahme, dass $\mathcal{M}$ eine glatte Mannigfaltigkeit ist, sodass kritische Werte überhaupt definiert sind}
Dies ermöglicht uns die notwendige Diskretisierung des Sweeps: Ein Knoten im Reeb-Graph kann nur auftreten, wenn zwei Komponenten verschmelzen (Merge), eine Komponente zerteilt wird (Split) oder eine Komponente beginnt oder endet, was alles notwendigerweise dadurch verursacht wird, dass zwei Entitäten direkt zusammenhängend werden (\emph{Connect}-Ereignis) oder es nicht länger sind (\emph{Disconnect}-Ereignis).\footnote{oder, dass das Ende des Beobachtungszeitraumes erreicht ist}
Definieren wir unsere Ereignisqueue bzw. $z$-Struktur also als die Folge aller Zeitpunkte zu denen zwei Entitäten genau den Abstand $2 \varepsilon$ haben, so enthält die Queue auf jeden Fall alle Zeitpunkte, an denen $\mathcal{R}$ aktualisiert werden muss.

Tatsächlich filtern wir schon bei der Berechnung dieser Queue Zeitpunkte heraus, die nicht \enquote{kritisch} sein können, das heißt die keine kritischen Werte sind.
Außerdem teilen wir die Zeitpunkte in diesem Arbeitsschritt bereits in \emph{Connect}- und \emph{Disconnect}-Ereignisse auf.
Wie dies genau vonstatten geht und wie die Queue konkret gespeichert wird, wird in \cref{sub:berechnung_queue} erläutert.
In \cref{sub:xy_struktur} wird dann die für einen Sweep-Algorithmus außerdem benötigte $xy$-Struktur beschrieben, bevor in \cref{sub:behandlung_der_ereignisse} die Verarbeitung der Ereignisse aus der Queue inklusive der Initialisierung der $xy$-Struktur behandelt wird.


\subsection{Berechnung der Queue} % (fold)
\label{sub:berechnung_queue}
Gegeben Entitäten $x$ und $y$ wollen wir eine Liste $L_{xy}$ aller Ereignisse berechnen.
Diese soll chronologisch sortiert sein und nur echt verschiedene Zeitpunkte enthalten.
Weiter sollen sich \emph{Connect}- und \emph{Disconnect}-Ereignisse stets abwechseln, was dazu dient, für den Reeb-Graphen uninteressante Ereignisse herauszufiltern wie zum Beispiel den Fall, dass der Abstand von $x$ und $y$ nur bis auf exakt $2 \varepsilon$ sinkt und danach wieder steigt.

Dazu betrachten wir in zeitlicher Reihenfolge die $\tau$ Zeitintervalle.
In einem solchen $\benbrace*{t_u,t_{u+1}}$ bewegen sich $x$ und $y$ nur entlang je einer Geraden, sodass der Abstand eine konvexe Funktion beschreibt.
Insbesondere gibt es entweder $k$ mit $k \in \set*{0,1,2}$ Zeitpunkte aus $\benbrace*{t_u,t_{u+1}}$, an denen der Abstand genau $2 \varepsilon$ ist oder dies gilt für jeden Zeitpunkt $t \in \benbrace*{t_u,t_{u+1}}$.
Es lässt sich in $\mathcal{O}(1)$ Zeit bestimmen, welcher der Fälle eintritt, und welches ggf. die $k$ Zeitpunkte sind.
Im ersten Fall fügen wir die $k$ Zeitpunkte in die Liste ein, im zweiten nur die Randpunkte $t_u$ und $t_{u+1}$; in beiden Fällen fügen wir die Zeitpunkte nicht ein, falls dadurch die Eindeutigkeit verletzt werden würde (asymptotisch kein zusätzlicher Aufwand, da nur das zuletzt eingefügte Element betrachtet werden muss).

In einem zweiten Schritt bereinigen wir $L_{xy}$ nun wie folgt: Wir iterieren über $L_{xy}$ und berechnen dabei für jeden Eintrag $t_i$, ob $x$ und $y$ im offenen Intervall $(t_i,t_{i+1})$ direkt zusammenhängend sind (Abstand beim Mittelpunkt bestimmen). 
Finden wir dadurch Zeitpunkte in $L_{xy}$, an denen sich der Zusammenhang von $x$ und $y$ nicht ändert, so entfernen wir diese aus der $L_{x,y}$.\todo{Zeichnung, dass der Fall tatsächlich eintreten kann}
Die Verbleibenden beschriften wir entsprechend mit \emph{Connect} oder \emph{Disconnect}.

$L_{xy}$ besteht aus $\mathcal{O}(\tau)$ Zeitpunkten und alle obigen Berechnungen kosten zusammen $\Theta(\tau)$ Zeit.
Berechnen wir diese Listen für alle $x,y$ und vereinigen sie mittels \textsc{MergeSort} zu einer Liste $L$, so entstehen also insgesamt $\mathcal{O}(\tau n^2 \log n^2) = \mathcal{O}(\tau n^2 \log n)$ Kosten und $L$ enthält $\mathcal{O}(\tau n^2)$ Zeitpunkte.
Beim Zusammenführen der Listen $L_{xy}$ speichern wir zu jedem \emph{Connect}-Ereignis einen Zeiger auf das nächste \emph{Disconnect}-Ereignis der gleichen Entitäten, sofern dies existiert.
Falls dies nicht existiert, soll der Zeiger auf $t_\tau$, also das Ende des betrachteten Zeitraumes, zeigen.
Dies ist asymptotisch betrachtet kein zusätzlicher Aufwand. 
% subsection berechnung_queue (end)

\subsection{Die $xy$-Struktur} % (fold)
\label{sub:xy_struktur}
Wir müssen zu jedem Zeitpunkt $t$ die Komponenten kennen.
Dazu benutzen wir den gewichteten Graphen $G=(\mathcal{X},Z)$, wobei $(x,y) \in Z$ genau dann, wenn die Entitäten $x$ und $y$ direkt zusammenhängend sind.
Das Gewicht der Kante $(x,y)$ ist der nächste Zeitpunkt, an dem $x$ und $y$ nicht mehr direkt zusammenhängend sind, also das nächste Disconnect-Ereignis bezüglich $x$ und $y$.
Eine Zusammenhangskomponente von $G$ entspricht genau einer Komponente (im Sinne von \cref{cha:def_gruppe}).
Um einen effizienten Zugriff auf die Komponenten zu bekommen, verwalten wir außerdem einen maximalen Spannbaum $F$ von $G$, den wir als ST-Baum speichern.

Die wertvolle Erkenntnis von \textcite{parsaReeb} war es nun, dass man durch obige Konstruktion nicht nur in $\mathcal{O}(\log n)$ Zeit herausfinden kann, in welcher Komponente sich eine Entität befindet, sondern $G$ \emph{und} $F$ auch in $\mathcal{O}(\log n)$ Zeit aktualisieren kann!
Dazu muss man ausnutzen, dass alle Ereignisse, die eine Aktualisierung nötig machen, schon im ersten Arbeitsschritt berechnet wurden.

Wir definieren unter Benutzung der Operationen eines ST-Baumes (siehe \cref{tbl:operationenST}) drei Funktionen $\textsc{Find}(x)$, $\textsc{Insert}(x,y)$ und $\textsc{Delete}(x,y)$, siehe \cref{alg:funktionen}.
Da die Operationen des ST-Baumes alle $\mathcal{O}(\log n)$ Zeit kosten, gilt dies auch für diese drei Funktionen und ermöglichen uns somit effiziente Zusammenhangsabfragen und Aktualisierungen von $F$.

\begin{algorithm}[p]
	\caption{Funktionen zur Zusammenhangsabfrage und Aktualisierung des maximalen Spannbaums $F$ nach \cite[Sec.~4.2]{parsaReeb}.}
	\label{alg:funktionen}
	\vspace{.5em}
	
	\begin{minipage}[c]{.35\textwidth}
		\mbox{ }
		\hrule
		\begin{algorithmic}
			\Function{Find}{x}
			\State \Return $\mathtt{root}(x)$
			\EndFunction
		\end{algorithmic}
		\hrule\vspace{2cm}
	
		\hrule
		\begin{algorithmic}
			\Function{Delete}{x,y}
			\State Lösche $(x,y)$ aus $G$
			\If{$(x,y)$ ist Kante in $F$}
			\State{$\mathtt{cut}(x,y)$}
			\EndIf
			\EndFunction
		\end{algorithmic}
		\hrule
	\end{minipage}\hfil
	\begin{minipage}[c]{.6\textwidth}
		\mbox{ }
		\hrule
		\begin{algorithmic}
			\Function{Insert}{x,y}
			\State $\omega \coloneqq$ Gewicht von $(x,y)$ \Comment{aus $L$ in $\mathcal{O}(1)$ auslesen}
			\State Füge $(x,y)$ mit Gewicht $\omega$ in $G$ ein
			\If{$\mathtt{root}(x) = \mathtt{root}(y)$}
			\State $\mathtt{evert}(x)$
			\State $x' \coloneqq \mathtt{minWeight}(y)$
			\State $\omega' \coloneqq$ Gewicht von $x'$ zum Elternknoten
			\If{$\omega' < \omega$}
			\State $\mathtt{cut} \enbrace*{x', \mathtt{parent}(x')}$
			\State $\mathtt{link}(x,y,\omega)$
			\EndIf
			\Else
			\State $\mathtt{link}(x,y,\omega)$
			\EndIf
			\EndFunction
		\end{algorithmic}
		\hrule
	\end{minipage}
\end{algorithm}

Neben $G$ und $F$ tritt im Laufe der Berechnung von $\mathcal{R}=(V,E)$ noch eine injektive Abbildung $M \colon \pi_0(G) \to V$ auf; jede Zusammenhangskomponente von $G$ (bzw. $F$) ist also noch eindeutig mit einem Knoten des Reeb-Graphen beschriftet.
% subsection xy_struktur (end)

\subsection{Behandlung der Ereignisse} % (fold)
\label{sub:behandlung_der_ereignisse}

% subsection behandlung_der_ereignisse (end)




% section berechnung_reeb (end)